需要用一个数组来保存用户的输入, 但是却不知道用户会输入多少条数据.

(1) 如果设一个太大的数组, 则显得浪费内存

(2) 如果设的太小, 又怕不够



问题: 如何做到恰好够用, 又一点不浪费呢?



C/C++ 里, 要求数组长度为常量



#### 动态内存分配 - malloc / free

系统中存在一个内存管理器(MM, Memory Manager), 它负责管理一堆闲置内存. 它被设计用于解决此类问题.

MM提供的服务: 应用程序可以向MM申请(借出)一块指定大小的内存, 用完之后再释放(还回).



例如:

```c
void* ptr = malloc(1024); // 申请, 从MM借出内存
free(ptr); // 释放, 还回MM
```



**malloc函数**

void* malloc(int size)

​	参数size: 指定要申请的内存空间的大小, 以字节为单位

​	返回值: void *,  指向这一块内存地址

(MM不关心你拿这块内存来存储何种数据, 所以返回void *)



应用程序在使用malloc时, 要把返回值转换成目标类型. 例如, 要申请一块空间存放1000个Contact对象, 则

```c
int size = 1000 * sizeof(struct Contact);
struct Contact * p = (struct Contact *)malloc(size);
```

这块内存和数组没有本质区别, 用法完全相同. 数组本质上就是一块连续的内存, 两者是一样的.



**free函数**

```c
void free(void * ptr);
```

ptr: 先前malloc返回的内存地址

返回值: void *, 指向这一块内存地址





#### 关于MM

(1) MM是一个系统级的东西， 所有的应用程序都向同一个MM申请内存。

(2) 何为借出？实际上，在内存被借出时，MM只是把它管理的内存标记了一下， 表示该段内存已经被占用。比如，它把每一段被占用的内存给记录下来（首地址， 长度）

`(p0, n0)`, `(p1, n1)` , `(p2, n2)`...

(3) MM非常慷慨： 1. 只要有人malloc， 它都同意借出； 2. 你不归还， 它永远不会主动要求你free;



这意味着， 用户程序应该自觉地及时归还（free）， 以便不耽误别的应用程序的使用。 如果有个应用程序不停地malloc, 而不free, 那最终会用光MM的内存。 当MM没有更多闲置内存时， malloc返回NULL, 表示内存已经用完。



MM管理的内存区域称为“堆”Heap, 相当于一个仓库。 当用程序要malloc时， 就从仓库里登记借出。 当free时，就将这一块内存放回仓库。



*再次重申： 应用程序在malloc之后， 应该尽早free!*



为何free的时候只需要一个首地址呢？为什么不传递长度？

实际上，MM对借出的内存块进行标识

`(p0, n0)`, `(p1, n1)` , `(p2, n2)`...

它内部已经保证任意两块内存不会“交叠”， 即不会重叠， 不会把一块内存同时借给两个应用程序使用。

所以，每块内存的首地址都是不同的， 在free的时候只需要指明首地址即可。

#### 小结

1. 使用malloc申请内存，具体申请多大的空间由你决定

2. 使用free释放内存

3. 使用原则：需要的时候再申请，不需要的时候立即释放

   
   
   
   
   
   
   
   
   #### 何为对象
   
   对象指的一块内存
   
   ```c
   struct Contact a; // a是一个对象, 即存放着一个对象的数据
   struct Contact *p = (struct Contact *)malloc(sizeof(struct Contact));
   ```
   
   确切地说, p指向了一个对象
   
   
   
   
   
   ##### 注意事项
   
   (1) 不是malloc的指针, 不可以free
   
   e.g.
   
   ```c
   int a = 10;
   int* p = &a;
   free(p); // 开什么玩笑... 这个指针根本不是从MM那里借来的
   ```
   
   
   
   (2) malloc的内存, 必须及时free
   
   怎么才算"及时"?
   
   "不及时"会怎样?
   
   
   
   MM中可用的内存是有限的, 你用完了就得尽快归还, 因为别的应用程序也需要MM的内存
   
   
   
   只借不还, 积累到一定程度, MM 没有更多内存可用, 于是malloc返回NULL
   
   
   
   ```c
   while(1)
   {
       void * ptr = malloc(1024 * 512);
   } // 这个代码写完运行之后, 电脑直接黑屏的说, 应该是直接die了...
   ```
   
   
   
   (3) 要free必须free首地址
   
   错误的例子:
   
   ```c
   char * p = (char *)malloc(100); // 100个字节
   free(p+50); // 借了100, 只还50
   ```
   
   要还就得全还, 否则MM那边处理不了. (p, n)
   
    (4) malloc的返回值需要检测
   
   ```c
       char * p = (char *)malloc(100);
       if(p != NULL)
       {
           strcpy(p, "hhhh");
           printf("%s\n", p);
       }
       else
       {
           printf("No memory!\n");
       }
   ```
   
   原因是: MM此时可能没有闲置内存可用.
   
   (5) free之后, 该指针不应再使用
   
   free之后, 该内存交还给MM, 该内存不再可用(失效).
   
   错误的例子:
   
   ```c
   char * p = (char *)malloc(100);
   free(p);
   for(int i = 0; i < 100; i++)
   {
       p[i] = i; // 该内存已经free啦, 不能继续使用!
   }
   ```
   
   良好的编程习惯是:
   
   ```c
   free(p);
   p = NULL;  // 置为空指针
   ```
   
   (6) malloc得到的内存, 可以任意位置释放
   
   不一定要在相同的函数里释放, 在应用程序的任意一个角落释放都是有效的.
   
   也就是说: 这一块内存被malloc出来之后, 完全交由你处置
   
   













